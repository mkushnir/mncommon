#!/bin/sh

cd `pwd`/`dirname $0`

echo '#ifndef DIAG_N' > diag.h
echo '#define DIAG_H' >> diag.h
echo "/* Autogenerated by `basename $0`. */" >> diag.h
echo '#include <stdlib.h>' >> diag.h
echo '#define DIAG_CLASS_MASK 0xffffff00' >> diag.h
echo '#define DIAG_CLASS_SHL 8' >> diag.h
echo 'struct _diag_entry_st {int cls; const char *fmt;};' >> diag.h
echo 'extern struct _diag_entry_st diag_table[];' >> diag.h
echo 'const char *diag_str(int);' >> diag.h
echo 'int diag_class(unsigned, unsigned);' >> diag.h
echo '#define FAIL(s) do { perror(s); abort(); } while (0)' >> diag.h


echo "/* Autogenerated by `basename $0`. */" > diag.c
echo '#include <stdio.h>' >> diag.c
echo '#include "diag.h"' >> diag.c
echo 'struct _diag_entry_st diag_table[] = {' >> diag.c

truncate -s0 diag.txt.tmp
for i in `cat diag.txt | sort -u `
do
    if grep -q $i *.[ch]
    then
        echo $i >> diag.txt.tmp
    fi
done
mv diag.txt.tmp diag.txt

cat diag.txt | (
    cls=0
    echo "#define DIAG_NOERROR (0<<DIAG_CLASS_SHL)" >> diag.h
    echo "{DIAG_NOERROR, \"DIAG_NOERROR+%d[%08x]\"}," >> diag.c
    cls=$((cls+1))
    while read str
    do
        test -z "$str" && continue
        echo "#define $str (${cls}<<DIAG_CLASS_SHL)" >> diag.h
        echo "{$str, \"$str+%d[%08x]\"}," >> diag.c
        cls=$((cls+1))
    done
)

echo '};
static char _diag_str[256];
const char *diag_str (int code)
{
    unsigned i;
    for (i = 0; i < sizeof(diag_table)/sizeof(struct _diag_entry_st); ++i) {
        if (diag_class(code, diag_table[i].cls)) {
            snprintf(_diag_str, sizeof(_diag_str), diag_table[i].fmt, (code & (~DIAG_CLASS_MASK)), code);
            return _diag_str;
        }
    }
    snprintf(_diag_str, sizeof(_diag_str), "unknown %d[%08x]", (code & (~DIAG_CLASS_MASK)), code);
    return _diag_str;
}

int diag_class (unsigned code, unsigned cls)
{
    return (code & DIAG_CLASS_MASK) == cls;
}
' >> diag.c
echo '#endif' >> diag.h
